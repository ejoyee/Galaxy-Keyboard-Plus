pipeline {
  agent any

  environment {
    // Firebase 배포 정보
    FIREBASE_TOKEN   = credentials('FIREBASE_TOKEN')
    FIREBASE_APP_ID  = '1:189536895445:android:783ed885fd7c4b896bfd5c'
    // 키스토어 관련 설정
    KEYSTORE_PASSWORD = credentials('KEYSTORE_PASSWORD')
    KEY_ALIAS        = credentials('KEY_ALIAS')
    KEY_PASSWORD     = credentials('KEY_PASSWORD')
    // CircleCI Android 이미지 사용
    DOCKER_IMAGE     = 'cimg/android:2023.08'
    // 작업 디렉토리 변수 추가
    WORK_DIR         = "${WORKSPACE}/workspace"
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        
        // 빌드 시작 로그
        sh '''
          echo "===================================================="
          echo "🚀 빌드 시작: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🔍 빌드 ID: ${BUILD_ID}"
          echo "🔍 Git 커밋: ${GIT_COMMIT}"
          echo "🔍 브랜치: ${GIT_BRANCH}"
          echo "🔍 작업 디렉토리: ${WORKSPACE}"
          echo "===================================================="
        '''
      }
    }

    stage('Check Docker Image') {
      steps {
        sh '''
          echo "===================================================="
          echo "🔍 Docker 이미지 확인"
          echo "===================================================="
          
          # Docker 이미지 확인
          if docker image inspect ${DOCKER_IMAGE} >/dev/null 2>&1; then
            echo "✅ Docker 이미지 ${DOCKER_IMAGE}가 이미 존재합니다."
          else
            echo "🔄 Docker 이미지 ${DOCKER_IMAGE}를 다운로드합니다."
            docker pull ${DOCKER_IMAGE} || {
              echo "❌ Docker 이미지 다운로드 실패! 사용 가능한 이미지인지 확인하세요."
              exit 1
            }
          fi
          
          echo "===================================================="
        '''
      }
    }

    stage('Prepare Build Environment') {
      steps {
        sh '''
          echo "===================================================="
          echo "🔧 빌드 환경 준비"
          echo "===================================================="
          
          # 임시 작업 디렉토리 생성 (전체 경로 사용)
          rm -rf ${WORK_DIR}
          mkdir -p ${WORK_DIR}
          
          # 디버깅: 원본 디렉토리 구조 확인
          echo "📂 원본 frontend 디렉토리 구조:"
          ls -la front/frontend/
          
          # 프로젝트 파일 복사 (모든 파일을 복사하기 위해 ./* 사용)
          echo "📂 프로젝트 파일 복사"
          cp -a front/frontend/. ${WORK_DIR}/
          
          # 파일 목록 확인 (더 자세한 로깅)
          echo "📂 복사된 파일 확인:"
          ls -la ${WORK_DIR}
          
          # package.json 확인
          echo "📄 package.json 확인:"
          cat ${WORK_DIR}/package.json | head -20 || echo "package.json 파일을 찾을 수 없습니다"
          
          # 권한 설정 (모든 사용자가 읽고 쓸 수 있도록)
          chmod -R 777 ${WORK_DIR}
          
          # 파일 권한 확인
          echo "📄 중요 파일 권한 확인:"
          ls -la ${WORK_DIR}/package.json || echo "package.json 파일을 찾을 수 없습니다"
          
          echo "===================================================="
        '''
      }
    }

    stage('Prepare Secret Files') {
      steps {
        withCredentials([
          file(credentialsId: 'android-release-keystore', variable: 'KEYSTORE_FILE'),
          file(credentialsId: 'google-services-json', variable: 'GOOGLE_SERVICES_JSON'),
          file(credentialsId: 'firebase-service-account', variable: 'FIREBASE_SERVICE_ACCOUNT')
        ]) {
          sh '''
            echo "===================================================="
            echo "🔐 시크릿 파일 준비"
            echo "===================================================="
            
            # 디렉토리 생성
            mkdir -p ${WORK_DIR}/android/app/keystore
            
            # 시크릿 파일 복사
            cp "$FIREBASE_SERVICE_ACCOUNT" ${WORK_DIR}/android/firebase_service_account.json
            cp "$GOOGLE_SERVICES_JSON" ${WORK_DIR}/android/app/google-services.json
            cp "$KEYSTORE_FILE" ${WORK_DIR}/android/app/keystore/release.keystore
            
            # 권한 설정
            chmod -R 777 ${WORK_DIR}/android/app/keystore
            chmod 666 ${WORK_DIR}/android/firebase_service_account.json
            chmod 666 ${WORK_DIR}/android/app/google-services.json
            chmod 666 ${WORK_DIR}/android/app/keystore/release.keystore
            
            echo "===================================================="
          '''
        }
      }
    }

    stage('Debug File System') {
      steps {
        sh '''
          echo "===================================================="
          echo "🔍 파일 시스템 디버깅"
          echo "===================================================="
          
          # 현재 디렉토리 및 작업 디렉토리 확인
          echo "📂 현재 디렉토리: $(pwd)"
          echo "📂 작업 디렉토리: ${WORK_DIR}"
          
          # 작업 디렉토리 내용 확인
          echo "📄 작업 디렉토리 내용:"
          ls -la ${WORK_DIR}
          
          # package.json 파일 시스템 정보 확인
          echo "📄 package.json 파일 시스템 정보:"
          stat ${WORK_DIR}/package.json || echo "package.json 파일 정보를 가져올 수 없습니다"
          
          # Docker 정보 확인
          echo "🐳 Docker 버전:"
          docker --version
          
          # SELinux 상태 확인 (볼륨 마운트에 영향을 줄 수 있음)
          echo "🔒 SELinux 상태:"
          getenforce 2>/dev/null || echo "SELinux 상태를 확인할 수 없습니다"
          
          # Docker 호스트 정보 확인
          echo "🐳 Docker 호스트 정보:"
          docker info | grep -E "Storage Driver|Root Dir"
          
          echo "===================================================="
          
          # 작업 디렉토리를 아카이브로 만들어 Docker에서 추출하는 대안 테스트
          echo "📦 작업 디렉토리 아카이브 생성"
          tar -czf ${WORKSPACE}/workspace.tar.gz -C ${WORK_DIR} .
          
          echo "===================================================="
        '''
      }
    }

    stage('Docker Volume Test') {
      steps {
        sh '''
          echo "===================================================="
          echo "🔍 Docker 볼륨 마운트 테스트 (다양한 방법 시도)"
          echo "===================================================="
          
          # 방법 1: 일반 볼륨 마운트
          echo "🔍 방법 1: 일반 볼륨 마운트"
          docker run --rm \
            -v "${WORK_DIR}:/project" \
            --workdir /project \
            ${DOCKER_IMAGE} \
            bash -c "ls -la && (cat package.json | head -5 || echo 'package.json 파일 없음')"
          
          # 방법 2: 파일 경로에 따옴표 추가
          echo "🔍 방법 2: 파일 경로에 따옴표 추가"
          docker run --rm \
            -v "${WORK_DIR}":/project \
            --workdir /project \
            ${DOCKER_IMAGE} \
            bash -c "ls -la && (cat package.json | head -5 || echo 'package.json 파일 없음')"
          
          # 방법 3: 아카이브 추출 방식
          echo "🔍 방법 3: 아카이브 추출 방식"
          docker run --rm \
            -v "${WORKSPACE}/workspace.tar.gz:/workspace.tar.gz" \
            ${DOCKER_IMAGE} \
            bash -c '
          echo "--- 컨테이너 내부 정보 ---"
          whoami  # 현재 사용자 확인
          ls -la /  # 루트 디렉토리 권한 확인
          echo "-------------------------"

          mkdir -p /project && tar -xzf /workspace.tar.gz -C /project && cd /project && ls -la && (cat package.json | head -5 || echo 'package.json 파일 없음')
        '
          
          echo "===================================================="
        '''
      }
    }

    stage('Build in Docker (Using Archive Method)') {
      steps {
        sh '''
          echo "===================================================="
          echo "🚀 Docker 내부에서 빌드 실행 (아카이브 방식)"
          echo "===================================================="
          
          # Docker 컨테이너 실행 (아카이브 방식)
          docker run --rm \
            -v "${WORKSPACE}/workspace.tar.gz:/workspace.tar.gz" \
            -v "${WORKSPACE}/apk:/output" \
            ${DOCKER_IMAGE} \
            bash -c '
              set -e  # 에러 발생 시 즉시 스크립트 중단
              
              # 작업 디렉토리 준비
              mkdir -p /project
              tar -xzf /workspace.tar.gz -C /project
              cd /project
              
              echo "📂 현재 디렉토리: $(pwd)"
              ls -la
              
              echo "📦 Node.js 종속성 설치"
              if [ ! -f "package.json" ]; then
                echo "❌ package.json 파일이 없습니다!"
                echo "현재 디렉토리 내용:"
                ls -la
                exit 1
              fi
              
              # Node.js 버전 확인
              NODE_VERSION=$(node --version || echo "Node.js가 설치되지 않았습니다")
              NPM_VERSION=$(npm --version || echo "npm이 설치되지 않았습니다")
              echo "Node.js 버전: $NODE_VERSION"
              echo "npm 버전: $NPM_VERSION"
              
              npm install
              
              echo "📂 node_modules 설치 확인"
              ls -la node_modules/@react-native || echo "React Native 모듈을 찾을 수 없습니다"
              
              echo "🔧 Android 빌드 준비"
              cd android
              chmod +x ./gradlew
              
              echo "🔧 local.properties 생성"
              echo "sdk.dir=$ANDROID_HOME" > local.properties
              
              echo "🔧 Gradle 프로퍼티 설정"
              cat >> gradle.properties << EOF

# CI 환경 키스토어 설정
KEYSTORE_PASSWORD='"'"'$KEYSTORE_PASSWORD'"'"'
KEY_ALIAS='"'"'$KEY_ALIAS'"'"'
KEY_PASSWORD='"'"'$KEY_PASSWORD'"'"'
EOF
              
              echo "🔧 Gradle 빌드 실행"
              ./gradlew clean --stacktrace
              ./gradlew assembleDebug --stacktrace
              
              echo "🔧 빌드 결과 확인"
              find . -name "*.apk" 
              
              # APK 파일 복사
              mkdir -p /output
              find . -name "*.apk" -exec cp {} /output/ ";"
            '
          
          # APK 파일 정리
          mkdir -p apk-archive
          find ${WORKSPACE}/apk -name "*.apk" -exec cp {} apk-archive/ ";" || echo "APK 파일이 없습니다"
          
          # 결과 확인
          APK_COUNT=$(find apk-archive -name "*.apk" | wc -l)
          
          if [ "$APK_COUNT" -gt 0 ]; then
            echo "✅ $APK_COUNT 개의 APK 파일이 있습니다:"
            find apk-archive -name "*.apk" | xargs ls -la
          else
            echo "❌ APK 파일이 없습니다"
            echo "No APK files found" > apk-archive/build-failed.txt
          fi
          
          echo "===================================================="
        '''
        
        archiveArtifacts artifacts: 'apk-archive/**', fingerprint: true, allowEmptyArchive: true
      }
    }

    stage('Deploy to Firebase') {
      steps {
        withCredentials([
          string(credentialsId: 'FIREBASE_TOKEN', variable: 'FIREBASE_TOKEN')
        ]) {
          sh '''
            echo "===================================================="
            echo "🔥 Firebase 배포"
            echo "===================================================="
            
            # APK 파일 찾기
            APK_FILE=$(find "${WORKSPACE}/apk-archive" -name "*.apk" | head -1)
            
            if [ -z "$APK_FILE" ]; then
              echo "❌ APK 파일을 찾을 수 없어 Firebase 배포를 건너뜁니다"
              exit 0
            fi
            
            echo "✅ 업로드할 APK 파일: $APK_FILE"
            
            # Firebase 배포 실행
            docker run --rm \
              -v "${APK_FILE}:/app.apk" \
              -e FIREBASE_TOKEN="$FIREBASE_TOKEN" \
              -e FIREBASE_APP_ID="$FIREBASE_APP_ID" \
              ${DOCKER_IMAGE} \
              bash -c '
                # Firebase CLI 설치
                npm install -g firebase-tools
                
                echo "🔥 Firebase App Distribution 실행"
                firebase appdistribution:distribute "/app.apk" \
                  --app "$FIREBASE_APP_ID" \
                  --token "$FIREBASE_TOKEN" \
                  --groups "testers" \
                  --release-notes "Jenkins CI 자동 배포 빌드 #${BUILD_ID} (${GIT_COMMIT})"
              '
            
            echo "===================================================="
          '''
        }
      }
    }
  }

  post {
    success {
      sh '''
        echo "===================================================="
        echo "✅ Frontend CI/CD 성공 🎉"
        echo "===================================================="
      '''
    }
    failure {
      sh '''
        echo "===================================================="
        echo "❌ Frontend CI/CD 실패 ❗"
        echo "===================================================="
        
        # 디버깅 정보 수집
        echo "# 빌드 실패 디버깅 정보" > debug-info.md
        echo "" >> debug-info.md
        
        echo "## 빌드 디렉토리 정보" >> debug-info.md
        ls -la ${WORK_DIR} 2>/dev/null >> debug-info.md || echo "빌드 디렉토리가 없습니다" >> debug-info.md
        echo "" >> debug-info.md
        
        echo "## package.json 파일 내용" >> debug-info.md
        cat ${WORK_DIR}/package.json 2>/dev/null >> debug-info.md || echo "package.json 파일이 없습니다" >> debug-info.md
        echo "" >> debug-info.md
        
        echo "## Docker 상태" >> debug-info.md
        docker info 2>/dev/null >> debug-info.md || echo "Docker 정보를 가져올 수 없습니다" >> debug-info.md
        echo "" >> debug-info.md
        
        # 디버깅 정보 아카이브
        mkdir -p debug-archive
        cp debug-info.md debug-archive/
        
        echo "📦 디버깅 정보가 debug-archive에 저장되었습니다"
      '''
      
      archiveArtifacts artifacts: 'debug-archive/**', fingerprint: true, allowEmptyArchive: true
    }
    always {
      sh '''
        echo "===================================================="
        echo "🧹 작업 공간 정리"
        echo "===================================================="
        
        # 임시 디렉토리 정리
        rm -rf ${WORK_DIR} workspace.tar.gz apk apk-archive debug-archive || true
      '''
      cleanWs()
    }
  }
}