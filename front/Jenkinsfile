pipeline {
  agent any

  environment {
    // Android SDK 설정
    ANDROID_SDK_ROOT = '/opt/android-sdk'
    ANDROID_HOME     = '/opt/android-sdk'
    // Fastlane Firebase App Distribution 토큰
    FIREBASE_TOKEN   = credentials('FIREBASE_TOKEN')
    // Firebase 앱 ID
    FIREBASE_APP_ID  = '1:189536895445:android:783ed885fd7c4b896bfd5c'
    // 키스토어 관련 설정
    KEYSTORE_PASSWORD = credentials('KEYSTORE_PASSWORD')
    KEY_ALIAS        = credentials('KEY_ALIAS')
    KEY_PASSWORD     = credentials('KEY_PASSWORD')
    // 사용할 Docker 이미지
    DOCKER_IMAGE     = 'my-android-ci:latest'
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        
        // 빌드 시작 로그
        sh '''
          echo "===================================================="
          echo "🚀 빌드 시작: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🔍 빌드 ID: ${BUILD_ID}"
          echo "🔍 Git 커밋: ${GIT_COMMIT}"
          echo "🔍 브랜치: ${GIT_BRANCH}"
          echo "===================================================="
        '''
      }
    }

    stage('Environment Diagnostic') {
      steps {
        sh '''
          echo "===================================================="
          echo "🔍 Jenkins 환경 진단"
          echo "===================================================="
          
          # 시스템 정보
          echo "📊 OS 정보:"
          uname -a
          
          # 설치된 도구 확인
          echo "📊 설치된 도구 확인:"
          which node || echo "Node.js가 설치되어 있지 않습니다"
          which npm || echo "npm이 설치되어 있지 않습니다"
          which yarn || echo "yarn이 설치되어 있지 않습니다"
          which java || echo "Java가 설치되어 있지 않습니다"
          which javac || echo "Java 컴파일러가 설치되어 있지 않습니다"
          
          # 환경 변수 확인
          echo "📊 환경 변수:"
          echo "PATH: $PATH"
          echo "ANDROID_HOME: $ANDROID_HOME"
          echo "ANDROID_SDK_ROOT: $ANDROID_SDK_ROOT"
          
          # Android SDK 확인
          echo "📊 Android SDK 확인:"
          [ -d "$ANDROID_SDK_ROOT" ] && ls -la $ANDROID_SDK_ROOT || echo "Android SDK 디렉토리가 없습니다"
          
          # 작업 디렉토리 구조
          echo "📊 작업 디렉토리 구조:"
          ls -la
          
          # Front 디렉토리 구조
          echo "📊 Front 디렉토리 구조:"
          ls -la front/
          
          # Frontend 디렉토리 구조
          echo "📊 Frontend 디렉토리 구조:"
          ls -la front/frontend/
          
          # Android 디렉토리 구조
          echo "📊 Android 디렉토리 구조:"
          ls -la front/frontend/android/
          
          echo "===================================================="
        '''
      }
    }

    stage('Docker Environment Diagnostic') {
      steps {
        sh '''
          echo "===================================================="
          echo "🔍 Docker 환경 진단"
          echo "===================================================="
          
          # Docker 버전 확인
          echo "📊 Docker 버전:"
          docker --version
          
          # Docker 이미지 확인
          echo "📊 사용 중인 Docker 이미지:"
          docker images ${DOCKER_IMAGE}
          
          # Docker 이미지 정보
          echo "📊 Docker 이미지 상세 정보:"
          docker image inspect ${DOCKER_IMAGE}
          
          # Docker 환경 확인
          echo "📊 Docker 환경 확인:"
          docker run --rm ${DOCKER_IMAGE} bash -c 'echo "OS: $(uname -a)" && echo "Node: $(node -v)" && echo "NPM: $(npm -v)" && echo "Yarn: $(yarn -v)" && echo "Java: $(java -version 2>&1)" && ls -la /workspace || echo "워크스페이스 디렉토리 없음" && ls -la / | grep workspace'
          
          echo "===================================================="
        '''
      }
    }

    stage('Docker Mount Test') {
      steps {
        sh '''
          echo "===================================================="
          echo "🔍 Docker 볼륨 마운트 테스트"
          echo "===================================================="
          
          # 임시 테스트 디렉토리 생성
          TEST_DIR=$(pwd)/test_mount
          mkdir -p ${TEST_DIR}
          echo "테스트 파일입니다" > ${TEST_DIR}/test.txt
          
          # 기본 볼륨 마운트 테스트
          echo "📊 기본 볼륨 마운트 테스트:"
          docker run --rm -v ${TEST_DIR}:/test ${DOCKER_IMAGE} bash -c 'ls -la /test && cat /test/test.txt'
          
          # 디렉토리 존재 테스트
          echo "📊 Docker 내부 디렉토리 확인:"
          docker run --rm ${DOCKER_IMAGE} bash -c 'ls -la / && ls -la /workspace || echo "워크스페이스 디렉토리 없음"'
          
          # 내부적으로 이미 존재하는 디렉토리에 마운트 테스트
          echo "📊 기존 디렉토리 마운트 테스트:"
          docker run --rm -v ${TEST_DIR}:/workspace ${DOCKER_IMAGE} bash -c 'ls -la /workspace && cat /workspace/test.txt || echo "파일 접근 실패"'
          
          # 하위 디렉토리 마운트 테스트
          echo "📊 하위 디렉토리 마운트 테스트:"
          docker run --rm -v $(pwd)/front/frontend:/workspace/frontend ${DOCKER_IMAGE} bash -c 'ls -la /workspace && ls -la /workspace/frontend || echo "프론트엔드 디렉토리 없음"'
          
          # 여러 디렉토리 마운트 테스트
          echo "📊 여러 디렉토리 마운트 테스트:"
          docker run --rm \
            -v $(pwd)/front/frontend:/project/frontend \
            -v $(pwd)/front/frontend/android:/project/android \
            ${DOCKER_IMAGE} \
            bash -c 'ls -la /project && ls -la /project/frontend && ls -la /project/android'
          
          # 정리
          rm -rf ${TEST_DIR}
          
          echo "===================================================="
        '''
      }
    }

    stage('Docker Build Test') {
      steps {
        sh '''
          echo "===================================================="
          echo "🔍 Docker 빌드 테스트"
          echo "===================================================="
          
          # 임시 작업 디렉토리 생성
          TEMP_DIR=$(pwd)/temp_docker_test
          mkdir -p ${TEMP_DIR}
          cp -r front/frontend/* ${TEMP_DIR}/
          
          # Docker 컨테이너로 빌드 환경 확인
          echo "📊 Docker 빌드 환경 확인:"
          docker run --rm \
            -v ${TEMP_DIR}:/project \
            -w /project \
            ${DOCKER_IMAGE} \
            bash -c '
              echo "현재 디렉토리: $(pwd)"
              echo "디렉토리 내용:"
              ls -la
              echo "Android 디렉토리:"
              ls -la android || echo "Android 디렉토리 없음"
              echo "Node 모듈:"
              ls -la node_modules || echo "node_modules 디렉토리 없음"
              echo "설치된 도구:"
              echo "Node: $(node -v)"
              echo "NPM: $(npm -v)"
              echo "Yarn: $(yarn -v)"
              echo "Java: $(java -version 2>&1 | head -1)"
            '
          
          # 정리
          rm -rf ${TEMP_DIR}
          
          echo "===================================================="
        '''
      }
    }
  }

  post {
    always {
      sh '''
        echo "===================================================="
        echo "📊 진단 결과 요약"
        echo "===================================================="
        
        # 진단 결과 파일 생성
        echo "# 환경 진단 결과" > diagnostic-results.md
        echo "" >> diagnostic-results.md
        
        echo "## Jenkins 환경" >> diagnostic-results.md
        echo "- OS: $(uname -a)" >> diagnostic-results.md
        echo "- Node.js: $(which node 2>/dev/null || echo '설치되지 않음')" >> diagnostic-results.md
        echo "- Java: $(which java 2>/dev/null || echo '설치되지 않음')" >> diagnostic-results.md
        echo "- Android SDK: $([ -d "$ANDROID_SDK_ROOT" ] && echo '존재함' || echo '존재하지 않음')" >> diagnostic-results.md
        echo "" >> diagnostic-results.md
        
        echo "## Docker 환경" >> diagnostic-results.md
        echo "- 이미지: ${DOCKER_IMAGE}" >> diagnostic-results.md
        echo "- 내부 워크스페이스: $(docker run --rm ${DOCKER_IMAGE} bash -c '[ -d /workspace ] && echo "존재함" || echo "존재하지 않음"')" >> diagnostic-results.md
        echo "" >> diagnostic-results.md
        
        echo "## 빌드 제안" >> diagnostic-results.md
        echo "환경 진단 결과를 바탕으로 다음 방법 중 하나를 선택하여 빌드를 진행하는 것이 좋습니다:" >> diagnostic-results.md
        echo "" >> diagnostic-results.md
        echo "1. **Docker 컨테이너 내 의존성 설치 및 빌드**: 모든 빌드 과정을 Docker 내에서 진행" >> diagnostic-results.md
        echo "2. **Jenkins에 Node.js 설치**: Jenkins 서버에 Node.js를 설치하여 직접 빌드" >> diagnostic-results.md
        echo "3. **Docker 없이 수동 빌드**: Docker를 사용하지 않고 Jenkins 서버에 필요한 모든 도구를 설치하여 빌드" >> diagnostic-results.md
        echo "" >> diagnostic-results.md
        
        echo "진단 결과가 diagnostic-results.md 파일에 저장되었습니다."
        
        # 진단 결과 아카이브를 위한 디렉토리 생성
        mkdir -p diagnostic-archive
        cp diagnostic-results.md diagnostic-archive/
        
        echo "===================================================="
      '''
      
      archiveArtifacts artifacts: 'diagnostic-archive/**', fingerprint: true, allowEmptyArchive: true
      
      cleanWs()
    }
  }
}